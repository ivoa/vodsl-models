
model stc2 (2.0) "STC2 is version 2 of the Data Model for the metadata describing Space-Time, related, and other coordinates. These metadata are suitable for specifying coordinate-realted information for datasets, catalogs, and queries. It consists of five packages that have, with one minor exception, uni-directional dependencies.1 coordsystem provides the metadata for the coordinate frame; it only has a dependency on coords if a custom spatial coordinate frame is specified that requires specification of a non-standard origin.2 coords provides the data types to specify coordinate values, errors, resolution, and units. Its only dependency is on coordsystem.3 frametransforms allows transformations and projections to be specified, including WCS transformations. If present, these objects are included in CoordFrames. Its only dependency is on coordsystem.4 coordarea provides the metadata model to specify coordinate volumes and ranges. It is dependent on coordsystem and coords.5 region is a further derived class of the spatial variety of coordarea, focused on specific 2-D shapes. It has direct dependencies on coordarea and coords."
     
 author "Arnold Rots"
       include "IVOA.vodsl"
     
package coordsystem  ""
{
      
abstract dtype SpaceRefPosition  "Abstract Data Type SpaceRefPosition is used by Time and Spatial Frames. It can either be instantiated as a Standard Reference Position or a Custom Reference Position."
  {   
  }

dtype StdSpaceRefPos  -> coordsystem.SpaceRefPosition "The Standard Space Reference Position is derived from the abstract SpaceRefPosition and is specified by a value from the StdRefPos enumerator."
  {   
        location: stctypes.StdRefPos   "";
  }

dtype CustomSpaceRefPos  -> coordsystem.SpaceRefPosition "The Custom Space Reference Position is derived from the abstract SpaceRefPosition and is specified by a Position."
  {   
        location: coords.Position   "";
  }

abstract otype CoordFrame  "This is the abstract empty base class for all coordinate frames, with the exception of pixel frames. It MAY contain any number of FrameTransforms, defining the mapping from this frame onto another CoordFrame."
  {   
        mapping : frametransforms.FrameTransform @*  as composition "";
  }

otype SpaceFrame  -> coordsystem.CoordFrame "A Spatial Frame is specified by its Reference Frame (currently only standard reference frames are allowed), a Reference Position, dimensionality, and a Flavor; an Equinox is optional and only required for pre-ICRS reference frames. It is to be referenced by spatial coordinates (Position and Velocity)."
  {   
        spaceRefFrame: stctypes.SpaceStdRefFrame   "";
        refPosition: coordsystem.SpaceRefPosition   "";
        equinox: stctypes.Epoch  @?   "";
        flavor: stctypes.CoordFlavor   "";
        ndim: ivoa:nonnegativeInteger   "";
  }

otype TimeFrame  -> coordsystem.CoordFrame "A TimeFrame HAS to include a Time Scale and a Reference Position and MAY include a Reference Direction and/or a Time Origin (for elapsed time)."
  {   
        timeScale: stctypes.TimeScale   "";
        refPosition: coordsystem.SpaceRefPosition   "";
        time0: stctypes.TimeStamp  @?   "";
  }

otype AstroCoordSystem  -> coordsystem.CoordSys "An AstroCoordSystem MAY contain up to three generic coordinate frames and one (or zero) of the following: TimeFrame, SpaceFrame, SpectralFrame, RedshiftFrame, PolarizationFrame. In addition, it MAY contain the name of a planetary ephemeris."
  {   
        planetaryEphem: ivoa:string  @?   "";
        timeFrame  @?  references coordsystem.TimeFrame "";
        spaceFrame  @?  references coordsystem.SpaceFrame "";
        spectralFrame  @?  references coordsystem.SpectralFrame "";
        redshiftFrame  @?  references coordsystem.RedshiftFrame "";
        polarizationFrame  @?  references coordsystem.PolarizationFrame "";
  }

otype SpectralFrame  -> coordsystem.SpectralLikeFrame "The Spectral Frame is identical to the SpectralLikeFrame, in that it is completely defined by its Reference Position. It is to be referenced by Spectral Coordinates."
  {   
  }

otype RedshiftFrame  -> coordsystem.SpectralLikeFrame "A Redshoft Frame is defined, in addition to its Reference Position (inherited from SpectralLikeFrame) by a Doppler Definition. It is to be referenced by Redshift Coordinates (either Redshift or Doppler velocity). The default value of dopplerDefinition is optical."
  {   
  }

otype GenericFrame  -> coordsystem.CoordFrame "A Generic Coordinate Frame contains the specification of its Handedness (default: left), and the number of its axes (it remains to be seen whether >1 is really required). It allows coordinates other than Time, Space, Spectral, Redshift, and Polarization to the defined; e.g., flux, temperature, pressure, etc. It is to be referenced by CoordSys."
  {   
        handedness: stctypes.Handedness  @?   "";
        naxes: ivoa:nonnegativeInteger   "";
  }

otype PolarizationFrame  -> coordsystem.CoordFrame "A Polarization Frame is uniquely defined by its Polarization Type: Stokes, Circular, Linear, or Vector."
  {   
        polType: stctypes.PolarizationType   "";
  }

abstract otype SpectralLikeFrame  -> coordsystem.CoordFrame "SpectralLikeFrame is the abstract base class for SpectralFrame and RedshiftFrame. These are related in that they share the same set of Reference Positions - which need to be specified in phase space."
  {   
  }

otype CoordSys  "A Coordinate System is a collection of Coordinate Frames.This class is the base-level coordinate system and MAY contain up to three generic coordinate frames."
  {   
        genericCoordFrame @[0..3] references coordsystem.GenericFrame "";
  }

}
  
package frametransforms  ""
{
      
dtype PixelCoordinate  "A Pixel Coordinate is a simpler kind of coordinate in that iit only contains naxes coordinate values as well as a reference to a Pixel Coordinate System."
  {   
        coordinateDomain: ivoa:string  @?   "" semantic "pixel" in "CoordinateDomains";
        naxes: ivoa:nonnegativeInteger   "";
        pixelCoord: ivoa:quantity.RealQuantity  @+   "";
        coordFrame  references frametransforms.PixelCoordSystem "";
  }

otype TransformMatrix2D  -> frametransforms.Xform2D ""
  {   
        cdMatrix: stctypes.Matrix2x2   "";
  }

abstract otype FrameTransform  ""
  {   
        handedness: stctypes.Handedness  @?   "";
        naxes: ivoa:nonnegativeInteger   "";
        transform : frametransforms.Xform @+  as composition "";
        targetFrame  references coordsystem.CoordFrame "";
  }

otype Scale2D  -> frametransforms.Xform2D ""
  {   
        scale: ivoa:real @[2..2]  "";
  }

otype Xlate1D  -> frametransforms.Xform1D ""
  {   
        nativeRefVal: ivoa:quantity.RealQuantity   "";
  }

otype Xlate2D  -> frametransforms.Xform2D ""
  {   
        nativeRefVal: stctypes.RealDoublet   "";
  }

otype Xlate3D  -> frametransforms.Xform3D ""
  {   
        nativeRefVal: stctypes.RealTriplet   "";
  }

otype Scale3D  -> frametransforms.Xform3D ""
  {   
        scale: ivoa:real @[3..3]  "";
  }

otype TransformMatrix3D  -> frametransforms.Xform3D ""
  {   
        cdMatrix: stctypes.Matrix3x3   "";
  }

otype PolStokes  -> frametransforms.PolFrameTransform ""
  {   
        pixel1Type: stctypes.PolStokes   "";
        pixel2Type: stctypes.PolStokes  @?   "";
        pixel3Type: stctypes.PolStokes  @?   "";
        pixel4Type: stctypes.PolStokes  @?   "";
  }

otype PolCircular  -> frametransforms.PolFrameTransform ""
  {   
        pixel1Type: stctypes.PolCircular   "";
        pixel2Type: stctypes.PolCircular  @?   "";
        pixel3Type: stctypes.PolCircular  @?   "";
        pixel4Type: stctypes.PolCircular  @?   "";
  }

otype PolLinear  -> frametransforms.PolFrameTransform ""
  {   
        pixel1Type: stctypes.PolLinear   "";
        pixel2Type: stctypes.PolLinear  @?   "";
        pixel3Type: stctypes.PolLinear  @?   "";
        pixel4Type: stctypes.PolLinear  @?   "";
  }

otype PolVector  -> frametransforms.PolFrameTransform ""
  {   
        pixel1Type: stctypes.PolVector   "";
        pixel2Type: stctypes.PolVector  @?   "";
        pixel3Type: stctypes.PolVector  @?   "";
        pixel4Type: stctypes.PolVector  @?   "";
  }

otype EnumScalar  -> frametransforms.Xform1D ""
  {   
        npix: ivoa:nonnegativeInteger   "";
        ec: ivoa:quantity.RealQuantity  @+   "";
  }

otype Enum2D  -> frametransforms.Xform2D ""
  {   
        npix: ivoa:nonnegativeInteger   "";
        ec: stctypes.RealDoublet  @+   "";
  }

otype Enum3D  -> frametransforms.Xform3D ""
  {   
        npix: ivoa:nonnegativeInteger   "";
        ec: stctypes.RealTriplet  @+   "";
  }

abstract otype PolFrameTransform  -> frametransforms.Xform1D ""
  {   
  }

otype Polynomial2D  -> frametransforms.Xform2D ""
  {   
        coeff : frametransforms.PolyCoeff2D @+  as composition "";
  }

otype Polynomial1D  -> frametransforms.Xform1D ""
  {   
        coeff : frametransforms.PolyCoeff1D @+  as composition "";
  }

otype Scale1D  -> frametransforms.Xform1D ""
  {   
        scale: ivoa:real   "";
  }

otype PixelAxis  "A Pixel Axis contains the number of pixels along the axis and the pixel axis number that its represents."
  {   
        naxis: ivoa:nonnegativeInteger   "";
        numpix: ivoa:nonnegativeInteger   "";
  }

otype PixelSpace  "A PixelSpace contains naxes (1, 2, or 3) Pixel Axes and is "
  {   
        naxes: ivoa:nonnegativeInteger   "";
        pixelAxes : frametransforms.PixelAxis@[1..3] as composition "";
  }

otype PixelFrame  -> coordsystem.CoordFrame "A PixelFrame forms the Coordinate Frame for a 1-D, 2-D, or 3-D pixel space, It contains a PixelFrameTransform, specifies the order of the axes from pixel space as they relate to the transform, and is included in the PixelCoordSystem. Note that, unlike other coordinate frames, a Pixel Frams is required to have at least one Frame Transform mapping: pixels without reference to the wider world are meaningless."
  {   
        nativeAxis1: ivoa:nonnegativeInteger   "";
        nativeAxis2: ivoa:nonnegativeInteger  @?   "";
        nativeAxis3: ivoa:nonnegativeInteger  @?   "";
  }

otype PixelCoordSystem  "A Pixel Coordinate System contains a Pixel Space and one or more Pixel Frames. It also defines its handedness (for two or more axes); left is default."
  {   
        handedness: stctypes.Handedness  @?   "";
        pixelFrame : frametransforms.PixelFrame @+  as composition "";
        pixelSpace : frametransforms.PixelSpace as composition "";
  }

abstract otype Xform  ""
  {   
        naxes: ivoa:nonnegativeInteger   "";
  }

abstract otype Xform1D  -> frametransforms.Xform ""
  {   
  }

abstract otype Xform2D  -> frametransforms.Xform ""
  {   
  }

otype Rotate2D  -> frametransforms.Xform2D ""
  {   
        rotationAngle: ivoa:real   "";
  }

abstract otype Xform3D  -> frametransforms.Xform ""
  {   
  }

otype Rotate3D  -> frametransforms.Xform3D ""
  {   
        rotationAngles: ivoa:real @[2..2]  "";
  }

otype Projection1D  -> frametransforms.Xform1D ""
  {   
        projection: stctypes.Projection   "";
  }

otype Projection3D  -> frametransforms.Xform3D ""
  {   
        projection: stctypes.Projection   "";
  }

otype Projection2D  -> frametransforms.Xform2D ""
  {   
        projection: stctypes.Projection   "";
  }

otype PolyCoeff1D  ""
  {   
        order: ivoa:integer  @?   "";
        value: ivoa:real  @?   "";
  }

otype PolyCoeff2D  ""
  {   
        order1: ivoa:integer  @?   "";
        order2: ivoa:integer  @?   "";
        value: ivoa:real  @?   "";
  }

otype PolyCoeff3D  ""
  {   
        order1: ivoa:integer  @?   "";
        order2: ivoa:integer  @?   "";
        order3: ivoa:integer  @?   "";
        value: ivoa:real  @?   "";
  }

otype Polynomial3D  -> frametransforms.Xform3D ""
  {   
        coeff : frametransforms.PolyCoeff3D @+  as composition "";
  }

}
  
package region  ""
{
      
abstract otype Region  -> coordarea.SpatialArea ""
  {   
        area: ivoa:quantity.RealQuantity  @?   "";
  }

otype Allsky  -> region.Region ""
  {   
  }

otype Box  -> region.Region ""
  {   
        size: stctypes.RealDoublet   "";
  }

otype Circle  -> region.Region ""
  {   
        size: stctypes.RealDoublet   "";
  }

otype Polygon  -> region.Region ""
  {   
        vertex : region.Vertex@[3..-1] as composition "";
  }

otype Vertex  ""
  {   
  }

otype ConvexHull  -> region.Polygon ""
  {   
  }

otype HalfSpace  ""
  {   
        offset: ivoa:real   "";
  }

otype Convex  -> region.Region ""
  {   
        halfSpace : region.HalfSpace @+  as composition "";
  }

otype Union  -> region.Region ""
  {   
        region  @+  references region.Region "";
  }

otype Intersection  -> region.Region ""
  {   
        region  @+  references region.Region "";
  }

otype Negation  -> region.Region ""
  {   
        region  references region.Region "";
  }

otype Difference  -> region.Region ""
  {   
        region1  references region.Region "";
        region2  references region.Region "";
  }

otype Ellipse  -> region.Region ""
  {   
        semiMajorAxis: ivoa:quantity.RealQuantity   "";
        semiMinorAxis: ivoa:quantity.RealQuantity   "";
        positionAngle: ivoa:quantity.RealQuantity   "";
  }

otype Sector  -> region.Region ""
  {   
        positionAngle1: ivoa:quantity.RealQuantity   "";
        positionAngle2: ivoa:quantity.RealQuantity   "";
  }

}
  
package coordarea  ""
{
      
otype CoordArea  ""
  {   
        name: ivoa:string  @?   "";
        coordSys  references coordsystem.CoordSys "";
        generic1  @?  references coordarea.GenericCoordInterval "";
        generic2  @?  references coordarea.GenericCoordInterval "";
        generic3  @?  references coordarea.GenericCoordInterval "";
  }

otype AstroCoordArea  -> coordarea.CoordArea ""
  {   
        timeInterval  @?  references coordarea.TimeInterval "";
        posIntv  @?  references coordarea.SpatialArea "";
        veloIntv  @?  references coordarea.VelocityInterval "";
        spectralIntv  @?  references coordarea.SpectralInterval "";
        redshiftIntv  @?  references coordarea.RedshiftInterval "";
        polCover  @?  references coordarea.PolCover "";
  }

abstract otype CoordInterval  ""
  {   
        lo_Include: ivoa:quantity.BooleanValue  @?   "";
        hi_Include: ivoa:quantity.BooleanValue  @?   "";
        fillFactor: ivoa:real  @?   "";
  }

otype GenericCoordInterval  -> coordarea.CoordInterval ""
  {   
        lo_Lim: ivoa:quantity.RealQuantity  @?   "";
        hi_Lim: ivoa:quantity.RealQuantity  @?   "";
  }

otype TimeInterval  -> coordarea.CoordInterval ""
  {   
        tstart: coords.Time  @?   "";
        tstop: coords.Time  @?   "";
  }

abstract otype SpatialArea  -> coordarea.CoordInterval ""
  {   
        epoch: stctypes.Epoch  @?   "";
  }

otype PositionInterval  -> coordarea.SpatialArea ""
  {   
        lo_Lim: coords.Position  @?   "";
        hi_Lim: coords.Position  @?   "";
  }

otype VelocityInterval  -> coordarea.CoordInterval ""
  {   
        epoch: stctypes.Epoch  @?   "";
        lo_Lim: coords.Velocity  @?   "";
        hi_Lim: coords.Velocity  @?   "";
  }

otype SpectralInterval  -> coordarea.CoordInterval ""
  {   
        lo_Lim: coords.SpectralCoord  @?   "";
        hi_Lim: coords.SpectralCoord  @?   "";
  }

otype RedshiftInterval  -> coordarea.CoordInterval ""
  {   
        lo_Lim: coords.Redshift  @?   "";
        hi_Lim: coords.Redshift  @?   "";
  }

otype PolCover  ""
  {   
        polCoord1: coords.PolCoord  @?   "";
        polCoord2: coords.PolCoord  @?   "";
        polCoord3: coords.PolCoord  @?   "";
        polCoord4: coords.PolCoord  @?   "";
  }

}
  
package coords  ""
{
      
dtype Time  -> coords.Coordinate "The value attribute of a Time Coordinate is of type TimeStamp. The remainder is as described in Coordinate."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "time" in "CoordinateDomains";
        value: stctypes.TimeStamp  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.TimeFrame "";
  }

abstract dtype Coordinate  "The abstract Datatype Coordinate, from which all coordinate Datatypes are derived, possesses two important properties: a refernce to a coordinate frame (after all, we need to know what kind of coordinate we are dealing with) and a CoordinateDomain semantic concept that, of course, is related to the coordinate system, but controls the units that are acceptable for the Coordinate. With the exception of Polarization coordinates (which are enumerated), coordinates will (optionally) contain a value; an error (unspecified); a systematic error; a random error; a resolution. These last four (if present) have type MultiStruct."
  {   
        coordinateDomain: ivoa:string   "" semantic "coordinate" in "CoordinateDomains";
        coordFrame  references coordsystem.CoordFrame "";
  }

abstract dtype GenericRedshiftCoord  -> coords.Coordinate "The value attribute of a Redshift Coordinate is a simple scalar Real Quantity. The remainder is as described in Coordinate. GenericRedshiftCoord is the abstract Datatype from which DopplerVelocity and Redshift are derived."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "redshift" in "CoordinateDomains";
        value: ivoa:quantity.RealQuantity  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.RedshiftFrame "";
  }

dtype DopplerVelocity  -> coords.GenericRedshiftCoord "The Doppler Velocity version of Generic Redshift Coordinate; the coordinateDomain top concept has been restricted."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "doppler" in "CoordinateDomains";
  }

abstract dtype SpectralCoord  -> coords.Coordinate "The value attribute of a Spectral Coordinate is a simple scalar Real Quantity. The remainder is as described in Coordinate. SpectralCoord is the abstract Datatype from which Frequency, Energy, and Wavelength are derived. It should not be used to specify redshifts or Doppler velocities - these are data types derived from the redshift coordinate."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "spectral" in "CoordinateDomains";
        value: ivoa:quantity.RealQuantity  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.SpectralFrame "";
  }

dtype Frequency  -> coords.SpectralCoord "The Frequency version of SpectralCoord; the coordinateDomain top concept has been restricted."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "frequency" in "CoordinateDomains";
  }

dtype Energy  -> coords.SpectralCoord "The Energy version of SpectralCoord; the coordinateDomain top concept has been restricted."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "energy" in "CoordinateDomains";
  }

dtype Wavelength  -> coords.SpectralCoord "The Wavelength version of SpectralCoord; the coordinateDomain top concept has been restricted. Contrary to Frequency and Energy which are invariant in the transmission medium, Wavelength allows a refractive index to be specified."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "wavelength" in "CoordinateDomains";
        refrIndex: ivoa:real  @?   "";
  }

dtype Redshift  -> coords.GenericRedshiftCoord "The Redshift version of Generic Redshift Coordinate; the coordinateDomain top concept has been restricted."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "z" in "CoordinateDomains";
  }

dtype GenericCoord  -> coords.Coordinate "The value attribute of a Generic Coordinate is a simple scalar Real Quantity. The remainder is as described in Coordinate. GenericCoord may be used to specify any coordinate or dependent variable that is not temporal, spatial, spectral, redshift, or polarization (e.g, flux density)."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "genericCoord" in "CoordinateDomains";
        value: ivoa:quantity.RealQuantity  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.GenericFrame "";
  }

abstract dtype SpatialCoord  -> coords.Coordinate "The value attribute of a Spatial Coordinate may be a 1-, 2-, or 3-dimensional QuantityVector. In addition, it  MUST have a dimensionality attribute (1, 2, or 3) and it MAY have an epoch. The remainder is as described in Coordinate. SpatialCoord is the abstract Datatype from which Position and Velocity are derived."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "spatial" in "CoordinateDomains";
        epoch: stctypes.Epoch  @?   "";
        ndim: ivoa:nonnegativeInteger   "";
        value: stctypes.QuantityVector   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.SpaceFrame "";
  }

dtype Position  -> coords.SpatialCoord "This is the spatial Position coordinate Datatype, derived from SpatialCoord; the top concept of the coordinate domain identifies the range of units acceptable for spatial positions."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "position" in "CoordinateDomains";
  }

dtype Velocity  -> coords.SpatialCoord "This is the spatial Velocity coordinate Datatype, derived from SpatialCoord; the top concept of the coordinate domain identifies the range of units acceptable for spatial velocities. Note that this data type is to be used for true spatial velocities (including proper motions), not for Doppler velocities - those are specified under Redshift coordinates."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "velocity" in "CoordinateDomains";
  }

abstract dtype PolCoord  -> coords.Coordinate "PolCoord is the abstract polarization datatype which may be realized in four possible forms: Stokes, Circular, Linear, or Vector. In all cases polarization is an enumerated coordinate since it can assume only a limited set of discrete values."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "polarization" in "CoordinateDomains";
        coordFrame  @?  references coordsystem.PolarizationFrame "";
  }

dtype Stokes  -> coords.PolCoord "The Stokes version of PolCoord; the coordinateDomain top concept has been restricted. The allowed values are of type PolStokes: I, Q, U, V."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "polStokes" in "CoordinateDomains";
        stokes: stctypes.PolStokes  @?   "";
  }

dtype Circular  -> coords.PolCoord "The Circular version of PolCoord; the coordinateDomain top concept has been restricted. The allowed values are of type PolCircular: RR, LL, RL, LR."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "polCircular" in "CoordinateDomains";
        circularPol: stctypes.PolCircular  @?   "";
  }

dtype Linear  -> coords.PolCoord "The Linear version of PolCoord; the coordinateDomain top concept has been restricted. The allowed values are of type PolLinear: XX, YY, XY, YX."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "polLinear" in "CoordinateDomains";
        linearPol: stctypes.PolLinear  @?   "";
  }

dtype Vector  -> coords.PolCoord "The Vector version of PolCoord; the coordinateDomain top concept has been restricted. The allowed values are of type PolStokes: I (total flux), PF (linearly polarized flux), PP (polarization percentage), PA (polarization angle)."
  {   
        coordinateDomain: ivoa:string  @?   "" subsets semantic "polVector" in "CoordinateDomains";
        polVector: stctypes.PolVector  @?   "";
  }

otype AstroCoords  -> coords.Coords "AstroCoords is a class that may specifically contain any of the astronomy-specific coordinates (space, time, spectral, redshift, polarization), in addition to the generic coordinates in Coords, the class from which it has been derived."
  {   
        time: coords.Time  @?   "";
        position: coords.Position  @?   "";
        velocity: coords.Velocity  @?   "";
        spectral: coords.SpectralCoord  @?   "";
        redshift: coords.GenericRedshiftCoord  @?   "";
        polarization: coords.PolCoord  @?   "";
  }

otype Coords  "Coords is a class that MAY contain up to three generic scalar coordinates."
  {   
        generic1: coords.GenericCoord  @?   "";
        generic2: coords.GenericCoord  @?   "";
        generic3: coords.GenericCoord  @?   "";
        coordSys  references coordsystem.CoordSys "";
  }

}
  
package stctypes  ""
{
      
enum TimeScale  ""
{
TT  "",
TDT  "",
ET  "",
TAI  "",
IAT  "",
UTC  "",
GPS  "",
TDB  "",
TEB  "",
TCG  "",
TCB  "",
LST  "",
LOCAL  ""
}

enum StdRefPos  "This is the enumerated list of allowed standard spatial and temporal reference positions."
{
GEOCENTER  "",
TOPOCENTER  "",
BARYCENTER  "",
HELIOCENTER  "",
GALACTIC_CENTER  "",
EMBARYCENTER  "",
MOON  "",
MERCURY  "",
VENUS  "",
MARS  "",
JUPITER  "",
SATURN  "",
URANUS  "",
NEPTUNE  "",
PLUTO  "",
RELOCATABLE  "",
UNKNOWNRefPos  ""
}

enum SpecRefPos  "This is the enumerated list of allowed spectral and redshift reference positions."
{
LSR  "",
LSRK  "",
LSRD  "",
LOCAL_GROUP_CENTER  "",
GEOCENTER  "",
TOPOCENTER  "",
BARYCENTER  "",
HELIOCENTER  "",
GALACTIC_CENTER  "",
EMBARYCENTER  "",
MOON  "",
MERCURY  "",
VENUS  "",
MARS  "",
JUPITER  "",
SATURN  "",
NEPTUNE  "",
PLUTO  "",
UNKNOWNRefPos  ""
}

enum SpaceStdRefFrame  "This is the enumerated lis of allowed standard spatial reference frames."
{
ICRS  "",
FK4  "",
FK5  "",
GALACTIC  "",
ECLIPTIC  "",
CUSTOM  "",
GALACTIC_I  "",
SUPER_GALACTIC  "",
AZ_EL  "",
BODY  "",
GEO_C  "",
GEO_D  "",
MAG  "",
GSE  "",
GSM  "",
SM  "",
HGC  "",
HGS  "",
HEEQ  "",
HRTN  "",
HPC  "",
HPR  "",
HCC  "",
HGI  "",
MERCURY_C  "",
VENUS_C  "",
LUNA_C  "",
MARS_C  "",
JUPITER_C_III  "",
SATURN_C_III  "",
URANUS_C_III  "",
NEPTUNE_C_III  "",
PLUTO_C  "",
MERCURY_G  "",
VENUS_G  "",
LUNA_G  "",
MARS_G  "",
JUPITER_G_III  "",
SATURN_G_III  "",
URANUS_G_III  "",
NEPTUNE_G_III  "",
PLUTO_G  "",
UNKNOWNFrame  ""
}

enum Projection  "This is th enumerated list of allowed mapping (transformation) projections."
{
LIN  "",
LOG  "",
TAN  "",
SIN  "",
STG  "",
ARC  "",
AIR  "",
ZEA  "",
CEA  "",
CAR  "",
MER  "",
SFL  "",
PAR  "",
MOL  "",
AIT  "",
COE  "",
COD  "",
COO  "",
BON  "",
PCO  "",
TSC  "",
CSC  "",
QSC  "",
POLYNOMIAL  "",
ENUMERATION  ""
}

enum DopplerDefinition  "Dopler/redshift definition"
{
optical  "",
radio  "",
relativistic  "",
redshift  ""
}

enum EpochType  "Epoch type: Julian or Besselian."
{
J  "",
B  ""
}

enum Handedness  "Handedness of a coorinate frame."
{
left  "",
right  ""
}

enum CoordFlavor  "The enumerated list of allowed coordinate flavors."
{
spherical  "",
cartesian  "",
polar  "",
cylindrical  "",
unitsphere  "",
healpix  "",
string  "",
polarization  ""
}

enum PolarizationType  "The four types of polarization mappings."
{
STOKES  "",
CIRCULAR  "",
LINEAR  "",
VECTOR  ""
}

enum PolStokes  ""
{
I  "",
Q  "",
U  "",
V  ""
}

enum PolCircular  ""
{
RR  "",
LL  "",
RL  "",
LR  ""
}

enum PolVector  ""
{
I  "",
PF  "",
PP  "",
PA  ""
}

enum PolLinear  ""
{
XX  "",
YY  "",
XY  "",
YX  ""
}

enum SpaceUnits  ""
{
m  "",
km  "",
mm  "",
um  "",
au  "",
pc  "",
kpc  "",
Mpc  "",
deg  "",
arcmin  "",
arcsec  "",
Angstrom  ""
}

enum TimeUnits  ""
{
s  "",
d  "",
a  "",
yr  "",
cy  ""
}

enum FreqUnits  ""
{
Hz  "",
kHz  "",
MHz  "",
GHz  ""
}

enum EnergyUnits  ""
{
eV  "",
keV  "",
MeV  "",
GeV  ""
}

dtype Epoch  ""
  {   
        type: stctypes.EpochType   "";
        year: ivoa:decimal   "";
  }

dtype RealDoublet  -> stctypes.QuantityVector ""
  {   
        v1: ivoa:quantity.RealQuantity   "";
        v2: ivoa:quantity.RealQuantity   "";
  }

dtype Matrix2x2  -> stctypes.Matrix ""
  {   
        m11: ivoa:real   "";
        m12: ivoa:real   "";
        m21: ivoa:real   "";
        m22: ivoa:real   "";
  }

dtype RealTriplet  -> stctypes.QuantityVector ""
  {   
        v1: ivoa:quantity.RealQuantity   "";
        v2: ivoa:quantity.RealQuantity   "";
        v3: ivoa:quantity.RealQuantity   "";
  }

dtype Matrix3x3  -> stctypes.Matrix ""
  {   
        m11: ivoa:real   "";
        m12: ivoa:real   "";
        m21: ivoa:real   "";
        m22: ivoa:real   "";
        m13: ivoa:real   "";
        m31: ivoa:real   "";
        m23: ivoa:real   "";
        m32: ivoa:real   "";
        m33: ivoa:real   "";
  }

abstract dtype TimeStamp  ""
  {   
  }

dtype ISOtime  -> stctypes.TimeStamp ""
  {   
        time: ivoa:datetime   "";
  }

dtype JD  -> stctypes.TimeStamp ""
  {   
        time: ivoa:real   "";
  }

dtype MJD  -> stctypes.TimeStamp ""
  {   
        time: ivoa:real   "";
  }

dtype TimeOffset  -> stctypes.TimeStamp ""
  {   
        offset: ivoa:real   "";
  }

abstract dtype Matrix  ""
  {   
  }

abstract dtype QuantityVector  ""
  {   
  }

dtype RealScalar  -> stctypes.QuantityVector ""
  {   
        v1: ivoa:quantity.RealQuantity   "";
  }

abstract dtype MultiStruct  ""
  {   
        ndim: ivoa:nonnegativeInteger   "";
  }

dtype Symmetrical  -> stctypes.MultiStruct ""
  {   
        radius: ivoa:quantity.RealQuantity   "";
  }

dtype Bounds  -> stctypes.MultiStruct ""
  {   
        loLimit: stctypes.QuantityVector   "";
        hiLimit: stctypes.QuantityVector   "";
  }

dtype Box  -> stctypes.MultiStruct ""
  {   
        boxSize: stctypes.QuantityVector   "";
  }

dtype Ellipse  -> stctypes.MultiStruct ""
  {   
        semiAxes: stctypes.QuantityVector   "";
        positionAngles: stctypes.QuantityVector   "";
  }

dtype MSMatrix  -> stctypes.MultiStruct ""
  {   
        matrix: stctypes.Matrix   "";
  }

}
  