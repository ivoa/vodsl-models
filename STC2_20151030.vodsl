
model stc2 (2.0) "
          TODO : Missing description : please, update your UML model asap.
        "
     
 author "Arnold Rots"
       include "IVOA.vodsl"
     
package coordsystem  ""
{
      
abstract dtype SpaceRefPosition  "Abstract Data Type SpaceRefPosition is used by Time and Spatial Frames. It can either be instantiated as a Standard Reference Position or a Custom Reference Position."
  {   
  }

dtype StdSpaceRefPos  -> coordsystem.SpaceRefPosition "The Standard Space Reference Position is derived from the abstract SpaceRefPosition and is specified by a value from the StdRefPos enumerator."
  {   
        location: stctypes.StdRefPos   "";
  }

dtype CustomSpaceRefPos  -> coordsystem.SpaceRefPosition "The Custom Space Reference Position is derived from the abstract SpaceRefPosition and is specified by a Position."
  {   
        location: coords.Position   "";
  }

abstract otype CoordFrame  "This is the abstract empty base class for all coordinate frames, with the exception of pixel frames."
  {   
        mapping : frametransforms.FrameTransform @*  as composition "";
  }

otype SpaceFrame  -> coordsystem.CoordFrame "A Spatial Frame is specified by its Reference Frame (currently only standard reference frames are allowed), a Reference Position, and a Flavor; an Equinox is optional and only required for pre-ICRS reference frames. It is to be referenced by spatial coordinates (Position and Velocity)."
  {   
        spaceRefFrame: stctypes.SpaceStdRefFrame   "";
        refPosition: coordsystem.SpaceRefPosition   "";
        equinox: stctypes.Epoch  @?   "";
        flavor: stctypes.CoordFlavor   "";
        ndim: ivoa.nonnegativeInteger   "";
  }

otype TimeFrame  -> coordsystem.CoordFrame "A TimeFrame HAS to include a Time Scale and a Reference Position and MAY include a Reference Direction and/or a Time Origin (for elapsed time)."
  {   
        timeScale: stctypes.TimeScale   "";
        refPosition: coordsystem.SpaceRefPosition   "";
        time0: stctypes.TimeStamp  @?   "";
  }

otype AstroCoordSystem  -> coordsystem.CoordSys "An AstroCoordSystem may contain any number of generic coordinate frames and one (or zero) of the following: TimeFrame, SpaceFrame, SpectralFrame, RedshiftFrame, PolarizationFrame. In addition, it may contain the name of a planetarry ephemeris."
  {   
        planetaryEphem: ivoa.string  @?   "";
        timeFrame  @?  references coordsystem.TimeFrame "";
        spaceFrame  @?  references coordsystem.SpaceFrame "";
        spectralFrame  @?  references coordsystem.SpectralFrame "";
        redshiftFrame  @?  references coordsystem.RedshiftFrame "";
        polarizationFrame  @?  references coordsystem.PolarizationFrame "";
  }

otype SpectralFrame  -> coordsystem.SpectralLikeFrame "The Spectral Frame is identical to the SpectralLikeFrame, in that it is completely defined by its Reference Position. It is to be referenced by Spectral Coordinates."
  {   
  }

otype RedshiftFrame  -> coordsystem.SpectralLikeFrame "A Redshoft Frame is defined, in addition to its Reference Position (inherited from SpectralLikeFrame) by a Doppler Definition. It is to be referenced by Redshift Coordinates (either Redshift or Doppler velocity)."
  {   
  }

otype GenericFrame  -> coordsystem.CoordFrame "A Generic Coordinate Frame contains the specification of its Handedness (default: left), number of axes (it remains to be seen whether >1 is really required), and Flavor. It allows coordinates other than Time, Space, Spectral, Redshift, and Polarization to the defined; e.g., flux, temperature, pressure, etc. It is to be referenced by Generic Coordinates."
  {   
        handedness: stctypes.Handedness  @?   "";
        naxes: ivoa.nonnegativeInteger   "";
  }

otype PolarizationFrame  -> coordsystem.CoordFrame "A Polarization Frame is uniquely defined by its Polarization Type: Stokes, Circular, Linear, or Vector."
  {   
        polType: stctypes.PolarizationType   "";
  }

abstract otype SpectralLikeFrame  -> coordsystem.CoordFrame "SpectralLikeFrame is the abstract base class for SpectralFrame and RedshiftFrame. These are related in that they share the same set of Reference Positions - which need to be specified in phase space."
  {   
  }

otype CoordSys  "A Coordinate System is a collection of Coordinate Frames.This class is the base-level coordinate system, containing any number (including zero) of generic coordinate frames."
  {   
        genericCoordFrame  @*  references coordsystem.GenericFrame "";
  }

}
  
package frametransforms  ""
{
      
dtype PixelCoordinate  ""
  {   
        coordinateDomain: ivoa.string  @?   "" semantic "pixel" in "CoordinateDomains";
        naxes: ivoa.nonnegativeInteger   "";
        pixelCoord: ivoa.quantity.RealQuantity @[3..3]  "";
        coordFrame  references frametransforms.PixelCoordSystem "";
  }

otype TransformMatrix2D  -> frametransforms.Xform2D ""
  {   
        cdMatrix: stctypes.Matrix2x2   "";
  }

abstract otype FrameTransform  ""
  {   
        handedness: stctypes.Handedness  @?   "";
        naxes: ivoa.nonnegativeInteger   "";
        transform : frametransforms.Xform @+  as composition "";
        targetFrame  references coordsystem.CoordFrame "";
  }

otype Scale2D  -> frametransforms.Xform2D ""
  {   
        scale: ivoa.real @[2..2]  "";
  }

otype Xlate1D  -> frametransforms.Xform1D ""
  {   
        nativeRefVal: ivoa.quantity.RealQuantity   "";
  }

otype Xlate2D  -> frametransforms.Xform2D ""
  {   
        nativeRefVal: stctypes.RealDoublet   "";
  }

otype Xlate3D  -> frametransforms.Xform3D ""
  {   
        nativeRefVal: stctypes.RealTriplet   "";
  }

otype Scale3D  -> frametransforms.Xform3D ""
  {   
        scale: ivoa.real @[3..3]  "";
  }

otype TransformMatrix3D  -> frametransforms.Xform3D ""
  {   
        cdMatrix: stctypes.Matrix3x3   "";
  }

otype PolStokes  -> frametransforms.PolFrameTransform ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        pixelType: stctypes.PolStokes @[3..3]  "";
  }

otype PolCircular  -> frametransforms.PolFrameTransform ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        pixelType: stctypes.PolCircular @[3..3]  "";
  }

otype PolLinear  -> frametransforms.PolFrameTransform ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        pixelType: stctypes.PolLinear @[3..3]  "";
  }

otype PolVector  -> frametransforms.PolFrameTransform ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        pixelType: stctypes.PolVector @[3..3]  "";
  }

otype EnumScalar  -> frametransforms.Xform1D ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        ec: ivoa.quantity.RealQuantity @[3..3]  "";
  }

otype Enum2D  -> frametransforms.Xform2D ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        ec: stctypes.RealDoublet @[3..3]  "";
  }

otype Enum3D  -> frametransforms.Xform3D ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        ec: stctypes.RealTriplet @[3..3]  "";
  }

abstract otype PolFrameTransform  -> frametransforms.Xform1D ""
  {   
  }

otype Polynomial2D  -> frametransforms.Xform2D ""
  {   
        order: ivoa.nonnegativeInteger   "";
        coeff: ivoa.real @[3..3]  "";
  }

otype Polynomial1D  -> frametransforms.Xform1D ""
  {   
        order: ivoa.nonnegativeInteger   "";
        coeff: ivoa.real @[3..3]  "";
  }

otype Scale1D  -> frametransforms.Xform1D ""
  {   
        scale: ivoa.real   "";
  }

otype PixelAxis  ""
  {   
        naxis: ivoa.nonnegativeInteger   "";
        numpix: ivoa.nonnegativeInteger   "";
  }

otype PixelSpace  ""
  {   
        naxes: ivoa.nonnegativeInteger   "";
        pixelAxes : frametransforms.PixelAxis@[1..3] as composition "";
  }

otype PixelFrame  -> coordsystem.CoordFrame "A PixelFrame forms the Coordinate Frame for a 1-D, 2-D, or 3-D pixel space, It contains a PixelFrameTransform, specifies the order of the axes from pixel space as they relate to the transform, and is included in the PixelCoordSystem."
  {   
        nativeAxis1: ivoa.nonnegativeInteger   "";
        nativeAxis2: ivoa.nonnegativeInteger  @?   "";
        nativeAxis3: ivoa.nonnegativeInteger  @?   "";
  }

otype PixelCoordSystem  ""
  {   
        handedness: stctypes.Handedness  @?   "";
        pixelFrame : frametransforms.PixelFrame @+  as composition "";
        pixelSpace : frametransforms.PixelSpace as composition "";
  }

abstract otype Xform  ""
  {   
        naxes: ivoa.nonnegativeInteger   "";
  }

abstract otype Xform1D  -> frametransforms.Xform ""
  {   
  }

abstract otype Xform2D  -> frametransforms.Xform ""
  {   
  }

otype Rotate2D  -> frametransforms.Xform2D ""
  {   
        rotationAngle: ivoa.real   "";
  }

abstract otype Xform3D  -> frametransforms.Xform ""
  {   
  }

otype Rotate3D  -> frametransforms.Xform3D ""
  {   
        rotationAngles: ivoa.real @[2..2]  "";
  }

otype Projection1D  -> frametransforms.Xform1D ""
  {   
        projection: stctypes.Projection   "";
  }

otype Projection3D  -> frametransforms.Xform3D ""
  {   
        projection: stctypes.Projection   "";
  }

otype Projection2D  -> frametransforms.Xform2D ""
  {   
        projection: stctypes.Projection   "";
  }

}
  
package region  ""
{
      
dtype Region  -> coordarea.SpatialArea ""
  {   
        area: ivoa.quantity.RealQuantity  @?   "";
  }

dtype Allsky  -> region.Region ""
  {   
  }

dtype Box  -> region.Region ""
  {   
        center: coords.Position   "";
        size: stctypes.RealDoublet   "";
  }

dtype Circle  -> region.Region ""
  {   
        center: coords.Position   "";
        size: stctypes.RealDoublet   "";
  }

dtype Ellipse  -> region.Region ""
  {   
        center: coords.Position   "";
        semiMajorAxis: ivoa.quantity.RealQuantity   "";
        semiMinorAxis: ivoa.quantity.RealQuantity   "";
        positionAngle: ivoa.quantity.RealQuantity   "";
  }

dtype Polygon  -> region.Region ""
  {   
        vertex: region.Vertex @[3..-1]  "";
  }

dtype Vertex  ""
  {   
        location: coords.Position   "";
        smallCirclePole: coords.Position  @?   "";
  }

dtype Convex  -> region.Region ""
  {   
        halfSpace: region.HalfSpace  @+   "";
  }

dtype HalfSpace  ""
  {   
        vector: coords.Position   "";
        offset: ivoa.real   "";
  }

dtype ConvexHull2D  -> region.Region ""
  {   
        point: coords.Position @[3..-1]  "";
  }

dtype ConvexHull3D  -> region.Region ""
  {   
        point: coords.Position @[3..-1]  "";
  }

dtype Sector  -> region.Region ""
  {   
        vertex: coords.Position   "";
        positionAngle1: ivoa.quantity.RealQuantity   "";
        positionAngle2: ivoa.quantity.RealQuantity   "";
  }

dtype SkyIndex  -> region.Region ""
  {   
  }

dtype Union  -> region.Region ""
  {   
        region1: region.Region   "";
        region2: region.Region   "";
  }

dtype Intersection  -> region.Region ""
  {   
        region1: region.Region   "";
        region2: region.Region   "";
  }

dtype Negation  -> region.Region ""
  {   
        region: region.Region   "";
  }

dtype Difference  -> region.Region ""
  {   
        region1: region.Region   "";
        region2: region.Region   "";
  }

}
  
package coordarea  ""
{
      
abstract dtype CoordInterval  ""
  {   
        lo_Include: ivoa.quantity.BooleanValue  @?   "";
        hi_Include: ivoa.quantity.BooleanValue  @?   "";
        fillFactor: ivoa.real  @?   "";
  }

dtype GenericCoordInterval  -> coordarea.CoordInterval ""
  {   
        lo_Lim: ivoa.quantity.RealQuantity  @?   "";
        hi_Lim: ivoa.quantity.RealQuantity  @?   "";
  }

dtype PositionInterval  -> coordarea.SpatialArea ""
  {   
        lo_Lim: coords.Position  @?   "";
        hi_Lim: coords.Position  @?   "";
  }

dtype VelocityInterval  -> coordarea.CoordInterval ""
  {   
        epoch: stctypes.Epoch  @?   "";
        lo_Lim: coords.Velocity  @?   "";
        hi_Lim: coords.Velocity  @?   "";
  }

dtype SpectralInterval  -> coordarea.CoordInterval ""
  {   
        lo_Lim: coords.SpectralCoord  @?   "";
        hi_Lim: coords.SpectralCoord  @?   "";
  }

dtype RedshiftInterval  -> coordarea.CoordInterval ""
  {   
        lo_Lim: coords.Redshift  @?   "";
        hi_Lim: coords.Redshift  @?   "";
  }

dtype TimeInterval  -> coordarea.CoordInterval ""
  {   
        tstart: coords.Time  @?   "";
        tstop: coords.Time  @?   "";
  }

dtype PolCover  ""
  {   
        npix: ivoa.nonnegativeInteger   "";
        polCoord: coords.PolCoord @[3..3]  "";
  }

abstract dtype SpatialArea  -> coordarea.CoordInterval ""
  {   
        epoch: stctypes.Epoch  @?   "";
  }

otype CoordArea  ""
  {   
        name: ivoa.string  @?   "";
        coordSys  references coordsystem.CoordSys "";
  }

otype AstroCoordArea  -> coordarea.CoordArea ""
  {   
  }

}
  
package coords  ""
{
      
dtype Time  -> coords.Coordinate ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "time" in "CoordinateDomains";
        value: stctypes.TimeStamp  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.TimeFrame "";
  }

abstract dtype Coordinate  ""
  {   
        coordinateDomain: ivoa.string   "" semantic "coordinate" in "CoordinateDomains";
        coordFrame  references coordsystem.CoordFrame "";
  }

abstract dtype GenericRedshiftCoord  -> coords.Coordinate ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "redshift" in "CoordinateDomains";
        value: ivoa.quantity.RealQuantity  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.RedshiftFrame "";
  }

dtype DopplerVelocity  -> coords.GenericRedshiftCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "doppler" in "CoordinateDomains";
  }

abstract dtype SpectralCoord  -> coords.Coordinate ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "spectral" in "CoordinateDomains";
        value: ivoa.quantity.RealQuantity  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.SpectralFrame "";
  }

dtype Frequency  -> coords.SpectralCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "frequency" in "CoordinateDomains";
  }

dtype Energy  -> coords.SpectralCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "energy" in "CoordinateDomains";
  }

dtype Wavelength  -> coords.SpectralCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "wavelength" in "CoordinateDomains";
        refrIndex: ivoa.real  @?   "";
  }

dtype Redshift  -> coords.GenericRedshiftCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "z" in "CoordinateDomains";
  }

dtype GenericCoord  -> coords.Coordinate ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "genericCoord" in "CoordinateDomains";
        value: ivoa.quantity.RealQuantity  @?   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.GenericFrame "";
  }

abstract dtype SpatialCoord  -> coords.Coordinate ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "spatial" in "CoordinateDomains";
        epoch: stctypes.Epoch  @?   "";
        ndim: ivoa.nonnegativeInteger   "";
        value: stctypes.QuantityVector   "";
        error: stctypes.MultiStruct  @?   "";
        sysError: stctypes.MultiStruct  @?   "";
        ranError: stctypes.MultiStruct  @?   "";
        resolution: stctypes.MultiStruct  @?   "";
        coordFrame  @?  references coordsystem.SpaceFrame "";
  }

abstract dtype Position  -> coords.SpatialCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "position" in "CoordinateDomains";
  }

abstract dtype Velocity  -> coords.SpatialCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "velocity" in "CoordinateDomains";
  }

abstract dtype PolCoord  -> coords.Coordinate ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "polarization" in "CoordinateDomains";
        coordFrame  @?  references coordsystem.PolarizationFrame "";
  }

dtype Stokes  -> coords.PolCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "polStokes" in "CoordinateDomains";
        stokes: stctypes.PolStokes  @?   "";
  }

dtype Circular  -> coords.PolCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "polCircular" in "CoordinateDomains";
        circularPol: stctypes.PolCircular  @?   "";
  }

dtype Linear  -> coords.PolCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "polLinear" in "CoordinateDomains";
        linearPol: stctypes.PolLinear  @?   "";
  }

dtype Vector  -> coords.PolCoord ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "polVector" in "CoordinateDomains";
        polVector: stctypes.PolVector  @?   "";
  }

otype AstroCoords  -> coords.Coords ""
  {   
        time: coords.Time  @?   "";
        position: coords.Position  @?   "";
        velocity: coords.Velocity  @?   "";
        spectral: coords.SpectralCoord  @?   "";
        redshift: coords.GenericRedshiftCoord  @?   "";
        polarization: coords.PolCoord  @?   "";
  }

otype Coords  ""
  {   
        generic: coords.GenericCoord  @*   "";
        coordSys  references coordsystem.CoordSys "";
  }

}
  
package stctypes  ""
{
      
enum TimeScale  ""
{
TT  "",
TAI  "",
UTC  "",
TDB  "",
TCG  "",
TCB  "",
ET  "",
GPS  ""
}

enum StdRefPos  ""
{
GEOCENTER  "",
TOPOCENTER  "",
BARYCENTER  "",
HELIOCENTER  "",
etc  ""
}

enum SpecRefPos  ""
{
LSR  "",
LSRK  "",
LSRD  "",
GEOCENTER  "",
TOPOCENTER  "",
BARYCENTER  "",
HELIOCENTER  "",
etc  ""
}

enum SpaceStdRefFrame  ""
{
ICRS  "",
FK4  "",
FK5  "",
GALACTIC  "",
ECLIPTIC  "",
CUSTOM  "",
etc  ""
}

enum Projection  ""
{
LIN  "",
LOG  "",
TAN  "",
SIN  "",
STG  "",
ARC  "",
AIR  "",
ZEA  "",
CEA  "",
CAR  "",
MER  "",
SFL  "",
PAR  "",
MOL  "",
AIT  "",
COE  "",
COD  "",
COO  "",
BON  "",
PCO  "",
TSC  "",
CSC  "",
QSC  "",
POLYNOMIAL  "",
ENUMERATION  ""
}

enum DopplerDefinition  ""
{
optical  "",
radio  "",
relativistic  "",
redshift  ""
}

enum EpochType  ""
{
J  "",
B  ""
}

enum Handedness  ""
{
left  "",
right  ""
}

enum CoordFlavor  ""
{
spherical  "",
cartesian  "",
polar  "",
cylindrical  "",
unitsphere  "",
healpix  "",
string  "",
polarization  ""
}

enum PolarizationType  ""
{
STOKES  "",
CIRCULAR  "",
LINEAR  "",
VECTOR  ""
}

enum PolStokes  ""
{
I  "",
Q  "",
U  "",
V  ""
}

enum PolCircular  ""
{
RR  "",
LL  "",
RL  "",
LR  ""
}

enum PolVector  ""
{
I  "",
PF  "",
PP  "",
PA  ""
}

enum PolLinear  ""
{
XX  "",
YY  "",
XY  "",
YX  ""
}

enum SpaceUnits  ""
{
m  "",
km  "",
mm  "",
um  "",
au  "",
pc  "",
kpc  "",
Mpc  "",
deg  "",
arcmin  "",
arcsec  "",
Angstrom  ""
}

enum TimeUnits  ""
{
s  "",
d  "",
a  "",
yr  "",
cy  ""
}

enum FreqUnits  ""
{
Hz  "",
kHz  "",
MHz  "",
GHz  ""
}

enum EnergyUnits  ""
{
eV  "",
keV  "",
MeV  "",
GeV  ""
}

dtype Epoch  ""
  {   
        type: stctypes.EpochType   "";
        year: ivoa.decimal   "";
  }

dtype RealDoublet  -> stctypes.QuantityVector ""
  {   
        v1: ivoa.quantity.RealQuantity   "";
        v2: ivoa.quantity.RealQuantity   "";
  }

dtype Matrix2x2  -> stctypes.Matrix ""
  {   
        m11: ivoa.real   "";
        m12: ivoa.real   "";
        m21: ivoa.real   "";
        m22: ivoa.real   "";
  }

dtype RealTriplet  -> stctypes.QuantityVector ""
  {   
        v1: ivoa.quantity.RealQuantity   "";
        v2: ivoa.quantity.RealQuantity   "";
        v3: ivoa.quantity.RealQuantity   "";
  }

dtype Matrix3x3  -> stctypes.Matrix ""
  {   
        m11: ivoa.real   "";
        m12: ivoa.real   "";
        m21: ivoa.real   "";
        m22: ivoa.real   "";
        m13: ivoa.real   "";
        m31: ivoa.real   "";
        m23: ivoa.real   "";
        m32: ivoa.real   "";
        m33: ivoa.real   "";
  }

abstract dtype TimeStamp  ""
  {   
  }

dtype ISOtime  -> stctypes.TimeStamp ""
  {   
        time: ivoa.datetime   "";
  }

dtype JD  -> stctypes.TimeStamp ""
  {   
        time: ivoa.real   "";
  }

dtype MJD  -> stctypes.TimeStamp ""
  {   
        time: ivoa.real   "";
  }

dtype TimeOffset  -> stctypes.TimeStamp ""
  {   
        offset: ivoa.real   "";
  }

abstract dtype Matrix  ""
  {   
  }

abstract dtype QuantityVector  ""
  {   
  }

dtype RealScalar  -> stctypes.QuantityVector ""
  {   
        v1: ivoa.quantity.RealQuantity   "";
  }

abstract dtype MultiStruct  ""
  {   
        ndim: ivoa.nonnegativeInteger   "";
  }

dtype Symmetrical  -> stctypes.MultiStruct ""
  {   
        radius: ivoa.quantity.RealQuantity   "";
  }

dtype Bounds  -> stctypes.MultiStruct ""
  {   
        loLimit: stctypes.QuantityVector   "";
        hiLimit: stctypes.QuantityVector   "";
  }

dtype Box  -> stctypes.MultiStruct ""
  {   
        boxSize: stctypes.QuantityVector   "";
  }

dtype Ellipse  -> stctypes.MultiStruct ""
  {   
        semiAxes: stctypes.QuantityVector   "";
        positionAngles: stctypes.QuantityVector   "";
  }

dtype MSMatrix  -> stctypes.MultiStruct ""
  {   
        matrix: stctypes.Matrix   "";
  }

}
  
package Specialized  ""
{
      
dtype SkyPosition  -> coords.Position ""
  {   
        coordinateDomain: ivoa.string  @?   "" subsets semantic "spherical" in "CoordinateDomains";
        coordFrame  @?  references Specialized.ICRSsky "";
  }

otype ICRSsky  -> coordsystem.SpaceFrame ""
  {   
  }

//package Specialized.SkyExample  ""
//{
//      
//}
  
}
  